# Codes for creating and smoothing modes
import numpy as np
def getModes(D, Cn, chisq_threshold=0.1):
    '''Calculate the compression matrix from n to u and the
    modes U that multiply each U.  
    Parameters:
    `D`:      The matrix J^T C_c^{-1} J, where C_c is the covariance
              matrix of the observables c, and J is the Jacobian dc/dn,
              shape=(N,N)
    `Cn`:     Covariance matrix of the n(z) parameter vector n, shape=(N,N)
    `chisq_threshold`:  Your desired upper bound for the mean error in chisq
              resulting from the compression.
    Returns:
    `X`:      The compression matrix, u = X @ n, shape=(nModes,N).  The
              covariance matrix of the u's will be the identity.
    `U`:      The decoding matrix, n' = U @ u, shape=(N,nModes)
    `dchisq`: The mean chisq shift generated by each mode, shape=(nModes)
    `resid`:  Mean amount of chisq shift caused by compression.

    You can safely use fewer than `nModes` of the returned X and U if you 
    think the discarded `dchisq` values are small enough.'''

    thr = 1e-25     # Dynamic range threshold for eigenvalues

    # Symmetrize and sqrt D
    D = 0.5*(D + D.T)
    Dval, Dvec = np.linalg.eigh(D)
    # Any negatives are numerical problems
    Dval = np.maximum(0., Dval)

    # And Cn
    Cnval, Cnvec = np.linalg.eigh(Cn)
    Cnval = np.maximum(0., Cnval)

    # Build the keystone matrix and its SVD
    M = np.einsum('i,ji,jk,k->ik',np.sqrt(Cnval), Cnvec, Dvec, np.sqrt(Dval))
    Um,s,Vmt = np.linalg.svd(M)

    # Sort SV's and throw away unwanted ones
    order = np.argsort(s*s)  # increasing order
    kill = np.count_nonzero(np.cumsum(s[order]**2) < chisq_threshold)
                                           
    resid = np.sum((s[order[:kill]]**2))

    keep = np.flip(order[kill:])  # Decreasing influence order
    Um = Um[:,keep]
    Vm = Vmt.T[:,keep]
    s = s[keep]

    # Build the encoder
    tmp = np.where(Cnval>thr*np.max(Cnval), 1/np.sqrt(Cnval), 0.)
    X = np.einsum('ij,i,ki->jk',Um, tmp, Cnvec)  # X is (M,N)
    # And the decoder
    tmp = np.where(Dval>thr*np.max(Dval), 1/np.sqrt(Dval), 0.)
    U = np.einsum('ji,i,ik,k->jk',Dvec, tmp, Vm,s)
    
    return X, U, s*s, resid

class Modes:
    def __init__(self, file):
        '''Compress or decompress n(z)'s into modes defined in the given file.'''
        self.a = np.load(file)
        
    def compress(self,nz):
        '''Compress n(z) array into mode coefficients.
        Argument is an (...,N) array of n(z) values that is already
        normalized according to conventions used to create modes.
        
        Returns (...,M) array of mode coefficients from projection.'''
        return np.einsum('...j,kj->...k',nz-self.a['mean'],self.a['X'])
    def decompress(self,u):
        '''Reconstruct n(z) from coefficients.
        Argument is (...,M) array of mode coefficients.
        Returns (...,N) array of n(z) values.'''
        return np.einsum('...j,kj->...k',u, self.a['U']) + self.a['mean']
 
class Tz:
    def __init__(self, dz, nz, z0=None):
        '''Class representing sawtooth n(z) kernels (bins) in z.
        First kernel is centered at z0, which defaults to dz if not
        given.  If z0<dz, then its triangle is adjusted to go to zero at
        0, then peak at z0, down to zero at z0+dz
        Arguments:
        `dz`: the step between kernel centers
        `nz`: the number of kernels.
        `z0`: peak of first bin'''
        self.dz = dz
        self.nz = nz
        if z0 is None:
            self.z0 = dz
        else:
            self.z0 = z0
        # Set a flag if we need to treat kernel 0 differently
        self.cut0 = self.z0<dz

    def __call__(self,k,z):
        '''Evaluate dn/dz for the kernel with index k at an array of
        z values.'''
        # Doing duplicative calculations to make this compatible
        # with JAX arithmetic.

        if self.cut0 and k==0:
            # Lowest bin is unusual:
            out = np.where(z>self.z0, 1-(z-self.z0)/self.dz, z/self.z0)
            out = np.maximum(0., out) / ((self.z0+self.dz)/2.)
        else:
            out = np.maximum(0., 1 - np.abs((z-self.z0)/self.dz-k)) / self.dz
        return out
    
    def zbounds(self):
        '''Return lower, upper bounds in z of all the bins in (nz,2) array'''
        zmax = np.arange(1,1+self.nz)*self.dz + self.z0
        zmin = zmax - 2*self.dz
        if self.cut0:
            zmin[0] = 0.
        return np.stack( (zmin, zmax), axis=1)
    
    def dndz(self,coeffs, z):
        '''Calculate dn/dz at an array of z values given set(s) of
        coefficients for the kernels/bins.  The coefficients will
        be normalized to sum to unity, i.e. they will represent the
        fractions within each kernel.
        Arguments:
        `coeffs`:  Array of kernel fractions of shape [...,nz]
        `z`:       Array of redshifts of arbitrary length
        Returns:
        Array of shape [...,len(z)] giving dn/dz at each z for
        each set of coefficients.'''
        
        # Make the kernel coefficients at the z's
        kk = np.array([self(k,z) for k in range(self.nz)])
        return np.einsum('...i,ij->...j',coeffs,kk) / np.sum(coeffs, axis=-1)

 
